<html>
<head><meta content="noindex,nofollow" name="robots"/>
<title>MIT's introductory computing subject</title>
</head>
<body bgcolor="#FFFFFF" link="#00009c" vlink="#00009c">
<img src="graphics/course-header.gif"/>
<p>
<br/>
<blockquote>
<hr/>
This material is excerpted and adapted from Hal Abelson, "Introductory
Undergraduate Subjects in Computer Science," which appeared in
<em>Syllabus</em>, February 1994.

<p>
<hr/>
<p>
MIT's entry-level computing subject, 6.001, emphasizes
controlling the complexity of software systems through general
techniques common to all engineering design: building abstractions to
hide details and to separate specification from implementation,
establishing conventional interfaces to allow the creation of standard
modules, and shifting modes of linguistic description.  Although the
course incorporates a great deal of programming, its intellectual
focus is not on particular programming-language constructs, data
structures, or algorithms -- these are regarded as details.  Instead,
students are brought to appreciate a diversity of major programming
paradigms: data abstraction, rule-based systems, object-oriented
programming, functional programming, logic programming, and
constructing embedded interpreters.  Beyond that, there is a central
concern with the technology of implementing languages and linguistic
support for programming paradigms.  Students are encouraged to regard
themselves as language designers and implementors rather than only
language users.

<p>

6.001 differs from typical introductory computer science subjects in
using Scheme (a block-structured dialect of Lisp) rather than Pascal
as its programming vehicle.  The subject's developers feel strongly
that Pascal is hopelessly constraining, and that important ideas (such
as functional programming and object-oriented programming) can be
addressed within Pascal only awkwardly, if at all.  In addition, they
consider top-down hierarchical design, so often emphasized as a
central theme in computer programming subjects, to be a minor and
relatively simplistic strategy in the programmer's arsenal for
attacking complex problems.

<p>

The course begins by introducing simple programs, written in
functional style (no assignment statements).  It discusses
substitution semantics, the evolution of processes, orders of growth,
and the use of higher-order procedures.  This leads to a treatment of
compound data (sequences and trees) and symbol manipulation, including
data abstraction and generic operations.  Next comes a study of
modularity in large-scale systems, introducing two different
techniques for maintaining modularity: object-oriented programming
with encapsulated local state; and functional
programming with delayed evaluation.  The course then turns to the
study of interpreters.  It presents a full interpreter for Scheme,
and, for comparison, an interpreter for a logic programming language
similar to pure Prolog.  In the final section, which deals with
register machines, the Scheme interpreter is implemented for a simple
register machine, and the register machine implementation is augmented
by a compiler that translates Scheme source code to register machine
instructions.

<p>

There are two exams during the semester, and a final exam, but the
crucial learning done by students is through substantial weekly
programming assignments.  These focus on reading and modifying
significant systems, rather than writing small programs from scratch.
Examples include an event-driven object-oriented simulation game, a
conversational program that uses rules and pattern matching, symbolic
algebra of polynomials and rational functions, interpreters for
various languages, and a compiler with register optimization.

<p>

The course is required of all MIT undergraduates majoring in either
Electrical Engineering or Computer Science, and is recommended for
other majors where computation pays a major role.  It is offered every
semester and taken by over 500 students each year -- half to
two-thirds of all MIT undergraduates.  Of the students enrolled in the
subject (normally in their freshman and sophomore years) more than
three-quarters have had previous programming experience, although
hardly any at the level of sophistication of 6.001.

<p>

MIT students regard 6.001 as an extremely challenging, but highly
successful subject, and they are uniformly impressed by the amount of
material they have mastered by the end of the semester.  The
Department of Electrical Engineering and Computer Science provides
considerable support for students enrolled in the subject.  There is
a large lecture that meets twice a week, and recitation sections of
20-30 students (typically taught by faculty) that meet twice a week.
There are also regular weekly tutorials, where students meet in groups
of three with a graduate TA to review homework and other course
material.  In addition, there is a large group of undergraduate
assistants who staff the programming laboratory.

<p>

The 6.001 textbook <em>Structure and Interpretation of Computer
Programs</em>, by H. Abelson, G.J. Sussman, and J. Sussman (MIT Press
and McGraw-Hill) is used at more than 100 colleges and universities.
The web site maintained by MIT Press at <a href="_/http/mitpress.mit.edu/sicp/index.html"><code>http://mitpress.mit.edu/sicp/</code></a>
contains material to assist instructors using the book.  This includes
excerpts from the book, a collection of sample assignments, and
information on where to obtain implementations of Scheme.

<p>
<br/>
<a href="sicp.html"><img src="back.gif"/></a>
<p>
<hr/>
<blockquote>Comments or questions <a href="_/https/mitpress.mit.edu/contact/index.html">Contact Us</a></blockquote>
<p>
<!-- hhmts start -->
Last modified: Mon Oct  7 17:59:32 1996
<!-- hhmts end -->
</p></p></p></p></p></p></p></p></p></p></p></blockquote>
</p><a href="https://dafoster.net/projects/crystal-web-archiver/" id="cr-footer-banner" style="border-top: 2px #B40010 solid;background: #FFFAE1;font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;font-variant: initial;font-weight: initial;text-transform: none;font-size: 14px;color: #6c757d;line-height: 2.0;cursor: pointer;display: flex;align-items: center;justify-content: center;gap: 4px;clear: both;" target="_blank"><img height="24" onerror="this.style['display'] = 'none';" src="_/crystal/resources/appicon.png" width="24"/><span>This page was archived with Crystal</span><script>window.addEventListener('load', function() { const $1 = document.querySelector('#cr-footer-banner'); if (!$1) { return; } if (window !== window.top) { let $2 = false; if (window.name) { const $3 = window.parent.document.getElementsByName(window.name); if ($3.length === 1) { const $4 = $3[0]; if ($4.tagName === 'FRAME' && $4.parentElement.tagName === 'FRAMESET') { let $5 = $4; while (true) { if ($5.parentElement.tagName !== 'FRAMESET') { $2 = true; break; } if ($5.parentElement.attributes['rows'] !== undefined) { const $6 = $5.parentElement.children; if ($5 === $6[$6.length - 1]) { $5 = $5.parentElement; continue; } else { break; } } else if ($5.parentElement.attributes['cols'] !== undefined) { const $7 = Array.from($5.parentElement.children); const $8 = $7.indexOf($5); if ($8 === -1) { break; } const $9 = $5.parentElement.attributes['cols'].value.split(','); const $10 = $9.map((s) => parseInt(s.trim())); if ($9[$8].trim() === '*' || $10[$8] === Math.max.apply(null, $10)) { $5 = $5.parentElement; continue; } else { break; } } else { break; } } } } } if (!$2) { $1.style['display'] = 'none'; } } const $11 = $1.getBoundingClientRect(); const $12 = ($11.y < window.innerHeight - $11.height); if ($12) { $1.style['position'] = 'fixed'; $1.style['bottom'] = '0'; $1.style['left'] = '0'; $1.style['right'] = '0'; $1.style['z-index'] = '9999'; } const $13 = ( document.body.getBoundingClientRect().height < $11.height * 2 ); if ($13) { $1.style['display'] = 'none'; }
});</script></a></body> </html>
